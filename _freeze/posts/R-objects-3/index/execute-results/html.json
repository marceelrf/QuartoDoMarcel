{
  "hash": "0cf066640f62e0102cdddd9e6fdad9b4",
  "result": {
    "markdown": "---\ntitle: \"R objects 3\"\ndescription: \"Lists\"\nauthor: \"Marcel Ferreira\"\ndate: \"2022-08-28\"\ncategories: [R, base]\nimage: \"checklist-gf5b297ead_1920.jpg\"\n---\n\n\n\n<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9124147692602552\"crossorigin=\"anonymous\"></script>\n\n\nIt is popularly known the curse of the third movie. Alien 3, Return of the Jedi, X-men: The Last Stand, Spider-Man 3, The Godfather 3, among others (MANY OTHERS) have suffered from this curse. However, MARVEL has overcome this curse recently with films like Infinity War, Thor Ragnarok, and Spider-Man with No Way Home. Inspired by her, we will conclude our trilogy of basic R objects. In this post we will look at `Lists`.\n\n## Lists\n\n`Lists` are objects similar to `vectors`, but each element can be a different object. That is, a list can contain a `vector` in one element, a `matrix` or `data.frame` in another, and even a `list` in a given element. That's right, `lists` within `lists`.\n\n<center>\n<iframe src=\"https://giphy.com/embed/13S1lWb5qheNBC\" width=\"480\" height=\"201\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/loop-dreaming-13S1lWb5qheNBC\">via GIPHY</a></p>\n</iframe>\n</center>\nThe function `list()` is used to create a list in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(1,3,5,7)\nv2 <- c(\"a\",\"b\")\ndf1 <- data.frame(var1 = c(1,2,3,4),\n                  var2 = c(\"a\",\"b\",\"c\",\"d\"),\n                  var3 = c(T,T,T,F))\n\nl1 <- list(v1,v2,df1)\nl1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 3 5 7\n\n[[2]]\n[1] \"a\" \"b\"\n\n[[3]]\n  var1 var2  var3\n1    1    a  TRUE\n2    2    b  TRUE\n3    3    c  TRUE\n4    4    d FALSE\n```\n:::\n:::\n\n\nWe can see that the output of a `list` contains differences from the others that we have seen. Each element number on a `list` is printed by R with double square brackets. Then R will print the elements as we have seen for each class.\n\nThis is something important to note when talking about how we extract elements from `lists`. If we use the single bracket operator the output will be a `list`, but only containing the element of that index. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Single square bracket\nl1[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"a\" \"b\"\n```\n:::\n\n```{.r .cell-code}\n#Double square bracket\nl1[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n:::\n\n\nWe can use the `class()` function to check the output classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Single square bracket\nclass(l1[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\n#Double square bracket\nclass(l1[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nWhen working with `lists` we can access elements internal to a given `list` element. To do this we use a double square bracket followed by a single square bracket. Example, let's extract the third element contained in the first element of the `list` `l1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The third element in the first list element\nl1[[1]][3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nThe third element of `l1` is a `data.frame`, we can extract its columns or rows in a similar way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#The first column of the data.frame in the third list element\nl1[[3]][,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\n#The rows number 2 and 3 in the data.frame in the third list element\nl1[[3]][2:3,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2 var3\n2    2    b TRUE\n3    3    c TRUE\n```\n:::\n:::\n\n\nJust as we can name columns and rows in `data.frames`/`matrix`, we can name each element in a `list`. This is done using the `names()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#unamed list\nnames(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nnames(l1) <- c(\"element1\",\"element2\",\"element3\")\n\n#named list\nnames(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"element1\" \"element2\" \"element3\"\n```\n:::\n:::\n\n\nAnd, as you may be wondering, we can use these names to extract elements from the `list` by passing them in the single or double square bracket operators. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$element1\n[1] 1 3 5 7\n\n$element2\n[1] \"a\" \"b\"\n\n$element3\n  var1 var2  var3\n1    1    a  TRUE\n2    2    b  TRUE\n3    3    c  TRUE\n4    4    d FALSE\n```\n:::\n\n```{.r .cell-code}\n#Single square bracket\nl1[c(\"element1\",\"element3\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$element1\n[1] 1 3 5 7\n\n$element3\n  var1 var2  var3\n1    1    a  TRUE\n2    2    b  TRUE\n3    3    c  TRUE\n4    4    d FALSE\n```\n:::\n\n```{.r .cell-code}\n#Double square bracket\nl1[[\"element1\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 7\n```\n:::\n:::\n\n\n## Concluding\n\nIn this three posts we have seen the main objects that form the basis of R. There are others, of course, but with these well understood we can solve the vast majority of challenges when working with R.\n\nI will soon create content showing operations with these objects in practice. That's it for now. See you around!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}