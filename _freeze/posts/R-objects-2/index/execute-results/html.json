{
  "hash": "925a9e06b3d7dc94ee5ffc2da9873604",
  "result": {
    "markdown": "---\ntitle: \"R objects 2\"\ndescription: \"Two dimensional objects\"\nauthor: \"Marcel Ferreira\"\ndate: \"2022-08-24\"\ncategories: [R, base]\nimage: \"matrix-2502954_1280.jpg\"\n---\n\n\n\n<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9124147692602552\"\n     crossorigin=\"anonymous\"></script>\n\n\nIn the last post ([**R objects**](https://quartodomarcel.netlify.app/posts/r-objects/)) we have seen the `atomic` classes and `vectors`, which are one-dimensional arrangements of these classes. But, as you can imagine, it's not always possible to represent our data using one-dimensional object. When talking about two-dimensional objects tables are something extremely common in our daily lives. R has two types of objects for representing tables (2D objects): `matrix` and `data.frames`, very similar objects, but with one **very important difference**: `matrix` only accept **ONE** `atomic` class, while `data.frames` accept **ONE** per column.\n\n## Matrix\n\nTo create a `matrix` we need a `vector` (Yes, a `vector`) and the function `matrix()`. This function takes the `vector` and arrange in a object containing the number of rows and columns that we specify in the arguments `nrow` and `ncol`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(1,2,3,1,2,3)\n\nMat1 <- matrix(data = v1,\n               nrow = 2,\n               ncol = 3)\nMat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    2    1    3\n```\n:::\n:::\n\n\nIt's possible to control the order of the elements in the `matrix` using the argument `byrow`, which controls whether the elements will be filled by rows or columns (***default***).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = v1,\n       nrow = 2,\n       ncol = 3,\n       byrow = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    1    2    3\n```\n:::\n\n```{.r .cell-code}\nmatrix(data = v1,\n       nrow = 2,\n       ncol = 3,\n       byrow = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    2    1    3\n```\n:::\n:::\n\n\nThe last argument, `dimnames`, allows us to choose names for the dimensions (rows and columns), but for this argument we need to use `lists`, and since we haven't talked about this object class yet, I will show you how to achieve the same results using functions. The functions `rownames()` and `colnames()` are used to extract the row and column names, respectively. We can use an `vector` of `characters`, equal in length to the number of rows or columns, to choose their names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Columns\ncolnames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\ncolnames(Mat1) <- c(\"Col1\",\"Col2\",\"Col3\")\ncolnames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Col1\" \"Col2\" \"Col3\"\n```\n:::\n\n```{.r .cell-code}\n#Rows\nrownames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nrownames(Mat1) <- c(\"Row1\",\"Row2\")\nrownames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Row1\" \"Row2\"\n```\n:::\n:::\n\n\nSimilar to `vectors`, we can extract the elements using squarebrackets, but now we have to pass the indices to rows and columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Extract the 2nd row\nMat1[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCol1 Col2 Col3 \n   2    1    3 \n```\n:::\n\n```{.r .cell-code}\n#Extract the 1st and 3rd columns\nMat1[,c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Col1 Col3\nRow1    1    2\nRow2    2    3\n```\n:::\n\n```{.r .cell-code}\n#Extract the element row = 2 column = 2\nMat1[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Data frames\n\n`Data frames` are objects design to store data tables in R. Similar to `matrix`, `data frames` are 2D objects but as said before, different columns can have different classes. In practice we can think of each column as being a different `vector`, and the `$` operator allows us to extract this `vector`. Thinking about data analysis, in a `data frame` each column is a variable and each row is an observation.\n\nWe build `data.frames` with the function `data.frame`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(var1 = c(1,2,3,4),\n                  var2 = c(\"a\",\"b\",\"c\",\"d\"),\n                  var3 = c(T,T,T,F))\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2  var3\n1    1    a  TRUE\n2    2    b  TRUE\n3    3    c  TRUE\n4    4    d FALSE\n```\n:::\n:::\n\n\nExtracting vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1$var1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\ndf1$var2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n\n```{.r .cell-code}\ndf1$var3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nAs for `matrix`, we can use squartebrackets to extract elements (although I recommend extracting using the `$` operator first).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Using squarebrackets\ndf1[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\"\n```\n:::\n\n```{.r .cell-code}\n#Using the $\ndf1$var2[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\"\n```\n:::\n:::\n\n\nThe names of columns (or variable) can be used in the squarebracket to extract the column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1[,\"var1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\nFor `matrix` and for `data.frames` we can find the sizes of the dimensions with the functions `nrow()`, `ncol()`, and `dim()`, which return the number of rows, columns, and both, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#number of rows\nnrow(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n#number of columns\nncol(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n#length of dimensions\ndim(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3\n```\n:::\n:::\n\n\nSo far, so good. In the next post I will deal with that `list` I talked about here, and we will see how powerful they are.\n\nI'll be waiting for you!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}