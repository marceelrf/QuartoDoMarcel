{
  "hash": "257d53d5e41fe76f82adfb7841e52fa0",
  "result": {
    "markdown": "---\ntitle: \"R objects 2\"\ndescription: \"Two dimensional objects\"\nauthor: \"Marcel Ferreira\"\ndate: \"2022-08-20\"\ncategories: [R, base]\nimage: \"matrix-2502954_1280.jpg\"\n---\n\n\nIn the last post (**R objects**) we have seen the `atomic` classes and `vectors`, which are one-dimensional arrangements of these classes. But, as you can imagine, it's not always possible to represent our data using one-dimensional object. When talking about two-dimensional objects tables are something extremely common in our daily lives. R has two types of objects for representing tables (2D objects): `matrix` and `data.frames`, very similar objects, but with one **very important difference**: `matrix` only accept **ONE** `atomic` class, while `data.frames` accept **ONE** per column.\n\n## Matrix\n\nTo create a `matrix` we need a `vector` (Yes, a `vector`) and the function `matrix()`. This function takes the `vector` and arrange in a object containing the number of rows and columns that we specify in the arguments `nrow` and `ncol`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(1,2,3,1,2,3)\n\nMat1 <- matrix(data = v1,\n               nrow = 2,\n               ncol = 3)\nMat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    2    1    3\n```\n:::\n:::\n\n\nIt's possible to control the order of the elements in the `matrix` using the argument `byrow`, which controls whether the elements will be filled by rows or columns (***default***).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = v1,\n       nrow = 2,\n       ncol = 3,\n       byrow = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    1    2    3\n```\n:::\n\n```{.r .cell-code}\nmatrix(data = v1,\n       nrow = 2,\n       ncol = 3,\n       byrow = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    2\n[2,]    2    1    3\n```\n:::\n:::\n\n\nThe last argument, `dimnames`, allows us to choose names for the dimensions (rows and columns), but for this argument we need to use `lists`, and since we haven't talked about this object class yet, I will show you how to achieve the same results using functions. The functions `rownames()` and `colnames()` are used to extract the row and column names, respectively. We can use an `vector` of `characters`, equal in length to the number of rows or columns, to choose their names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Columns\ncolnames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\ncolnames(Mat1) <- c(\"Col1\",\"Col2\",\"Col3\")\ncolnames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Col1\" \"Col2\" \"Col3\"\n```\n:::\n\n```{.r .cell-code}\n#Rows\nrownames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nrownames(Mat1) <- c(\"Row1\",\"Row2\")\nrownames(Mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Row1\" \"Row2\"\n```\n:::\n:::\n\n\nSimilar to `vectors`, we can extract the elements using squarebrackets, but now we have to pass the indices to rows and columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Extract the 2nd row\nMat1[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCol1 Col2 Col3 \n   2    1    3 \n```\n:::\n\n```{.r .cell-code}\n#Extract the 1st and 3rd columns\nMat1[,c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Col1 Col3\nRow1    1    2\nRow2    2    3\n```\n:::\n\n```{.r .cell-code}\n#Extract the element row = 2 column = 2\nMat1[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Data frames\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}